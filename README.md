# postgres-ha-docker-vm

Deploy HA Postgres Cluster on VM with Docker and Docker Compose

## Reasons for using Docker to deploy Postgres Cluster on VMs instead using K8S or OS packages

- Postgres Operators in K8S mostly use one StorageClass - one Storage Backed.
  Then in some environment, it's not enough to ensure that oone Storge Backend
  can bring confident High Availability for HA Postgres Cluster.
- Why using containerize instead using os packages (rpm, deb...)? Containerize
  allow you make consistent deployments in any environments withouts aware
  about OS, packages not found in yum, deb repository...

## Overral Deployment Architecture

![deployment-architecture.png](./images/deployment-architecture.png)

## How the system works

TODO

## Environemt

- OS VM: Ubuntu 20.04 Server
- Docker + Docker Compose
- Etcd 3.5.2 (Containerize)
- PostgreSQL 13.3 (Containerize)
- Patroni 2.1.4 (Containerize)
- PgBackrest 2.41 (Containerize)
- S3 Compatible Object Storage Solution -  Ceph Rados Gateway

## Deploy

Prepare 4 VMs, 3 VMs for Postgres Cluster, 1 VM for PGBackrest Backup Repostory.

For example in this document:

Postgres Cluster VMs:

- 192.168.150.201 pg-srv1
- 192.168.150.202 pg-srv2
- 192.168.150.203 pg-srv3

PGBackrest Backup Repostory VM:

- 192.168.150.211 pg-backup-repo-server1

## Prepare

### Prepare Container Image

Build Container Image:

Following PGBackrest document to generate `pgbackrest` binary file

<https://pgbackrest.org/user-guide.html#build>

Then put output `pgbackrest` binary file to working directory then build

```bash
docker-compose build postgres
```

Then push your container image to your container registry repository

### Prepare SSL Certificates for PGBackrest


For example, you have following servers on cluster:

- 192.168.150.201 pg-srv1
- 192.168.150.202 pg-srv2
- 192.168.150.203 pg-srv3

- 192.168.150.211 pg-backup-repo-server1

Then you need to perform following commands to generate certificate for servers

```bash
mkdir certs && cd certs
openssl req -new -x509 -days 36500 -nodes -out ca.crt -keyout ca.key -subj "/CN=root-ca"
openssl req -new -nodes -out pg-backup-repo-server1.csr -keyout pg-backup-repo-server1.key -subj "/CN=pg-backup-repo-server1"
openssl req -new -nodes -out pg1-srv.csr -keyout pg1-srv.key -subj "/CN=pg1-srv"
openssl req -new -nodes -out pg2-srv.csr -keyout pg2-srv.key -subj "/CN=pg2-srv"
openssl req -new -nodes -out pg3-srv.csr -keyout pg3-srv.key -subj "/CN=pg3-srv"
openssl x509 -req -in pg-backup-repo-server1.csr -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -out pg-backup-repo-server1.crt
openssl x509 -req -in pg1-srv.csr -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -out pg1-srv.crt
openssl x509 -req -in pg2-srv.csr -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -out pg2-srv.crt
openssl x509 -req -in pg3-srv.csr -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -out pg3-srv.crt
rm *.csr
```

If you have more servers, for example `pg4-srv`, perform these commands to generate
certificates for new server:

```bash
$ openssl req -new -nodes -out pg4-srv.csr -keyout pg4-srv.key -subj "/CN=pg4-srv"
$ openssl x509 -req -in pg4-srv.csr -days 36500 -CA ca.crt -CAkey ca.key -CAcreateserial -out pg4-srv.crt
```

### Prepare Host Environment

### Initial New Cluster

### Setup Etcd Cluster

TODO

### Setup Patroni Postgres Cluster

#### Setup Postgres Master Server

Jump to first host `pg-srv1`.

Create user `postgres` with `UID 1001`, group `postgres` with `GID 1001`.
Grant user `postgres` `docker` and `docker-compose` permission

```bash
groupadd  -g 1001 postgres
useradd -u 1001 -g postgres postgres
```

The reason we assign ID `1001` to `postgres` OS user in this document, is we will
using UID `1001` to run Postgres containers. Therefore we will create
user `postgres` which has same UID `1001` with user `postgres` inside container
to mount `postgres` data folder from host OS to docker container. When os user
has same name and UID with user run in container, it will allow you using
os user `postgres` to read Postgres cluster config and log generated by user
in container. In the scenario you don't need to mount folder from os host to
container, just switch to using docker volume.

Then using `postgres` os user to perform following commands:

Clone this GitHub Repo to working directory.

Create `patroni-config.yml` file following example config file

```yaml
# postgresql cluster name
scope: postgres01
# postgresql cluster instance name
name: patroni-192.168.150.201
restapi:
    # replace with postgres server IP Address
    listen: 192.168.150.201:8000
    # replace with postgres server IP Address    
    connect_address: 192.168.150.201:8000


etcd:
    # replace with etcd cluster IP Addresses
    hosts: 192.168.150.201:2379,192.168.150.202:2379,192.168.150.203:2379

bootstrap:
    dcs:
        ttl: 30
        loop_wait: 10
        retry_timeout: 10
        maximum_lag_on_failover: 1048576
        postgresql:
            use_pg_rewind: true

    initdb:
    - encoding: UTF8
    - data-checksums

    # allow cluster network can receive replication data from postgres master server
    pg_hba:
    - host replication replicator 127.0.0.1/32 md5
    - host replication replicator 192.168.150.0/24 md5
    - host all all 0.0.0.0/0 md5

postgresql:
    # replace with postgres server IP Address
    listen: 192.168.150.201:5432
    # replace with postgres server IP Address    
    connect_address: 192.168.150.201:5432
    # postgres data directory inside container
    data_dir: /home/postgres/postgres-data/data
    pgpass: /home/postgres/postgres-data/pass
    authentication:
        replication:
            username: replicator
            password: --REPLICATIOR-PASSWORD--
        superuser:
            username: postgres
            password: --POSTGRES-SUPERUSER-PASSWORD--
        rewind:  # Has no effect on postgres 10 and lower
            username: rewind_user
            password:  --REWIND-PASSWORD--
    parameters:
        unix_socket_directories: /home/postgres/postgres-data/unix
        archive_mode: on
        # archive WAL files to  pgbackrest repository host
        archive_command: pgbackrest --stanza=postgres01 archive-push "%p"
        logging_collector: true
        log_directory: /home/postgres/postgres-data/logs
        log_filename: postgres.log
        log_rotation_size: 50000
        log_truncate_on_rotation: true
        log_file_mode: 0604
        log_min_duration_statement: 250
        shared_buffers: 128MB
        max_connections: 200

log:
    level: INFO
    dir: /home/postgres/postgres-data/logs
    file_num: 1

tags:
    nofailover: false
    noloadbalance: false
    clonefrom: false
    nosync: false
```

Create following folders:

- `{WORKING_DIR}/postgres-data/data`
- `{WORKING_DIR}/postgres-data/logs`

```bash
$ mkdir -p postgres-data/data
$ mkdir -p postgres-data/logs
```

Copy generated certificates to `{WORKING_DIR}/pgbackrest/certs` folder

Create `pgbackrest.conf` configuration file from example configuration file

```conf
# pgbackrest.conf
[global]
# Backup Server Domain name, in this document is pg-backup-repo-server1
repo1-host=pg-backup-repo-server1
# User which run pgbackrest server process in backup repo host, used when 
# Postgres master send WAL file from Postgres master to backup repo
# In this document it is postgres, because we always using postgres to run
# pgbackrest process inside Docker container
repo1-host-user=postgres
log-level-console=info
log-level-file=debug
delta=y
repo1-host-type=tls
#The certificates we use to authenticate with PGBackrest Repo Server
repo1-host-cert-file=/home/postgres/pgbackrest/certs/pg1-srv.crt
repo1-host-key-file=/home/postgres/pgbackrest/certs/pg1-srv.key
repo1-host-ca-file=/home/postgres/pgbackrest/certs/ca.crt

# tls server options
# The certificates we use to create local PGBackrest Server, which will be 
# connected by PGBackrest backup process when full backup command is executed
tls-server-address=*
tls-server-cert-file=/home/postgres/pgbackrest/certs/pg1-srv.crt
tls-server-key-file=/home/postgres/pgbackrest/certs/pg1-srv.key
tls-server-ca-file=/home/postgres/pgbackrest/certs/ca.crt
# This config will allow PGBackrest backup process executted in PGBackrest Repo 
# Server using backup repo certificates to authenticate with local PGBacrest
# Server run on Postgres Master Server
tls-server-auth=pg-backup-repo-server1=*

[postgres01]
# The postgres data location in Docker container, must be the same value with
# data_dir config in patroni configuration file
pg1-path=/home/postgres/postgres-data/data
```

Create `.env` file from `env.example` example configuration. Ensure that
`PG_DATA_PATH` and `PGBACKREST_CERT_PATH` is configured correctly with config
in `patroni-config.yml` and `pgbackrest.conf` files

```env
PG1_HOST=192.168.150.201
PG2_HOST=192.168.150.202
PG3_HOST=192.168.150.203
PG4_HOST=127.0.0.1
PGBACKREST_REPO_HOST=192.168.150.211
IMAGE_TAG=13.3-buster-2.1.4
IMAGE_NAME=postgres-patroni
PG_BASE_IMG=13.3-buster
PATRONI_VERSION=2.1.4
PG_DATA_PATH=/home/postgres/postgres-data/data
PG_LOG_PATH=/home/postgres/postgres-data/logs
PGBACKREST_CERT_PATH=/home/postgres/pgbackrest/certs
```

Review configure by command:

`docker-compose config`

Start `postgres` and `pgbackrest` containers:

```bash
docker-compose pull
docker-compose up -d postgres pgbackrest
```

#### Setup PGBackrest Backup Repository Server

#### Initiate First Full Backup

### Perform Full Backup

### Create new Postgres Secondary VM

### Rollback or Recreate Cluster from PGBackrest Backup Data

### Handle when PGBackrest Repository Down and can not recover

## References

- https://pgstef.github.io/2022/02/21/pgbackrest_tls_server.html
- https://pgstef.github.io/2022/07/12/patroni_and_pgbackrest_combined.html
- https://github.com/zalando/patroni/blob/v2.1.4/kubernetes/Dockerfile